name: Build and Deploy to EKS

on:
  push:
    branches: [ "main" ]
    paths:
      - 'app/**'
      - 'docker/**'
      - 'k8s/**'
  pull_request:
    branches: [ "main" ]
    paths:
      - 'app/**'
      - 'docker/**'
      - 'k8s/**'
  workflow_dispatch:
  
permissions:
  contents: write
  pull-requests: write
  id-token: write

env:
  AWS_REGION: us-west-2
  EKS_CLUSTER_NAME: flask-eks-cluster
  ECR_REPOSITORY: flask-microservice-app

jobs:
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.image.outputs.image }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build a docker container and push it to ECR
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f docker/Dockerfile .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Also tag as latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kube config
      run: aws eks update-kubeconfig --name $EKS_CLUSTER_NAME --region $AWS_REGION

    - name: Install AWS Load Balancer Controller
      run: |
        # Check if AWS Load Balancer Controller is already installed
        if ! kubectl get deployment -n kube-system aws-load-balancer-controller > /dev/null 2>&1; then
          # Download IAM policy
          curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.5.4/docs/install/iam_policy.json
          
          # Create IAM policy
          aws iam create-policy \
            --policy-name AWSLoadBalancerControllerIAMPolicy \
            --policy-document file://iam_policy.json || true
          
          # Create service account
          eksctl create iamserviceaccount \
            --cluster=$EKS_CLUSTER_NAME \
            --namespace=kube-system \
            --name=aws-load-balancer-controller \
            --role-name AmazonEKSLoadBalancerControllerRole \
            --attach-policy-arn=arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):policy/AWSLoadBalancerControllerIAMPolicy \
            --approve || true
          
          # Install AWS Load Balancer Controller using Helm
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            --set clusterName=$EKS_CLUSTER_NAME \
            --set serviceAccount.create=false \
            --set serviceAccount.name=aws-load-balancer-controller
        fi

    - name: Deploy to EKS
      env:
        IMAGE_URI: ${{ needs.build.outputs.image }}
      run: |
        # Update the image in deployment
        sed -i "s|ACCOUNT_ID.dkr.ecr.REGION.amazonaws.com/flask-microservice-app:latest|$IMAGE_URI|g" k8s/deployment.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml
        kubectl apply -f k8s/ingress.yaml
        kubectl apply -f k8s/hpa.yaml
        
        # Wait for deployment to be ready
        kubectl rollout status deployment/flask-app -n flask-app --timeout=300s
        
        # Get the load balancer URL
        echo "Waiting for load balancer to be ready..."
        sleep 60
        kubectl get ingress flask-app-ingress -n flask-app

  test:
    name: Test Application
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kube config
      run: aws eks update-kubeconfig --name $EKS_CLUSTER_NAME --region $AWS_REGION

    - name: Test Application Health
      run: |
        # Get the load balancer URL
        LB_URL=$(kubectl get ingress flask-app-ingress -n flask-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        if [ -z "$LB_URL" ]; then
          echo "Load balancer URL not found, testing via port-forward"
          kubectl port-forward -n flask-app svc/flask-app-service 8080:80 &
          sleep 10
          curl -f http://localhost:8080/health || exit 1
          curl -f http://localhost:8080/ || exit 1
        else
          echo "Testing application at: http://$LB_URL"
          # Wait for DNS propagation
          sleep 120
          curl -f http://$LB_URL/health || exit 1
          curl -f http://$LB_URL/ || exit 1
        fi